<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æƒ…æ›¸è±ªè¯ç‰ˆ - 32å¼µç‰Œèˆ‡NPCå°æ±º</title>
    <style>
        :root { --primary: #e74c3c; --bg: #2c3e50; --card: #34495e; --accent: #f1c40f; }
        body { font-family: "PingFang TC", "Heiti TC", "Microsoft JhengHei", sans-serif; background-color: var(--bg); color: white; margin: 0; padding: 10px; }
        .container { max-width: 800px; margin: auto; background: var(--card); border-radius: 12px; padding: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        h1 { text-align: center; color: var(--accent); margin-top: 0; }
        
        /* éŠæˆ²ç‹€æ…‹èˆ‡æ—¥èªŒ */
        .status-panel { display: flex; justify-content: space-between; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px; margin-bottom: 15px; border: 1px solid var(--accent); }
        #log { background: #1a252f; height: 180px; overflow-y: auto; padding: 10px; border-radius: 5px; font-size: 14px; margin-bottom: 15px; display: flex; flex-direction: column-reverse; }
        .log-entry { margin: 2px 0; border-bottom: 1px solid #2c3e50; padding: 2px 0; }
        .important { color: var(--accent); font-weight: bold; }

        /* ç©å®¶é¡¯ç¤ºå€ */
        .player-list { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 10px; margin-bottom: 20px; }
        .player-card { background: #5d6d7e; padding: 10px; border-radius: 8px; text-align: center; border: 2px solid transparent; transition: 0.3s; }
        .player-card.active { border-color: var(--accent); transform: scale(1.05); }
        .player-card.out { opacity: 0.3; background: #2c3e50; text-decoration: line-through; }
        .player-card.protected { border-color: #2ecc71; }

        /* æŒ‰éˆ•èˆ‡äº’å‹• */
        .hand-area { display: flex; flex-wrap: wrap; justify-content: center; gap: 8px; margin-top: 5px; }
        button { background: var(--primary); color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold; transition: 0.2s; }
        button:hover { background: #c0392b; transform: translateY(-2px); }
        button:disabled { background: #95a5a6; cursor: not-allowed; transform: none; }
        .setup-screen { text-align: center; padding: 40px 0; }
        input { padding: 8px; width: 60px; border-radius: 5px; border: none; margin-right: 10px; }
    </style>
</head>
<body>

<div class="container">
    <h1>ğŸ’Œ æƒ…æ›¸è±ªè¯ç‰ˆ (32å¼µ)</h1>

    <div id="setup-screen" class="setup-screen">
        <h3>é¸æ“‡åƒèˆ‡äººæ•¸ (2-8äºº)</h3>
        <input type="number" id="playerCount" value="4" min="2" max="8">
        <button onclick="startGame()">é–‹å§‹éŠæˆ² (é€²å…¥çŒœæ‹³)</button>
    </div>

    <div id="game-screen" style="display: none;">
        <div class="status-panel">
            <span>ğŸ´ å‰©é¤˜ç‰Œæ•¸: <b id="deck-count">0</b></span>
            <span id="game-dir-display">ğŸ”„ æ–¹å‘: é †æ™‚é‡</span>
        </div>

        <div id="player-list" class="player-list"></div>

        <div id="log"></div>
    </div>
</div>

<script>
    // éŠæˆ²å¸¸æ•¸èˆ‡è®Šæ•¸
    const CARD_TYPES = [
        { v: 1, name: "è¡›å…µ", count: 10 }, { v: 2, name: "ç¥çˆ¶", count: 4 },
        { v: 3, name: "ç”·çˆµ", count: 4 }, { v: 4, name: "ä¾å¥³", count: 4 },
        { v: 5, name: "ç‹å­", count: 4 }, { v: 6, name: "åœ‹ç‹", count: 2 },
        { v: 7, name: "ä¼¯çˆµå¤«äºº", count: 2 }, { v: 8, name: "å…¬ä¸»", count: 2 }
    ];

    let players = [], deck = [], currentPlayerIdx = 0, gameDir = 1;
    let isGameOver = false;

    // --- éŠæˆ²æµç¨‹æ§åˆ¶ ---

    function startGame() {
        const count = parseInt(document.getElementById('playerCount').value);
        if (count < 2 || count > 8) return alert("äººæ•¸éœ€åœ¨ 2~8 ä¹‹é–“");

        initDeck();
        initPlayers(count);

        document.getElementById('setup-screen').style.display = 'none';
        document.getElementById('game-screen').style.display = 'block';

        addLog("ğŸ² éŠæˆ²æº–å‚™ä¸­ï¼Œæ­£åœ¨æ¨¡æ“¬ç©å®¶çŒœæ‹³...", "important");
        setTimeout(handleRPS, 1000);
    }

    function initDeck() {
        deck = [];
        CARD_TYPES.forEach(card => {
            for (let i = 0; i < card.count; i++) deck.push({ ...card });
        });
        deck.sort(() => Math.random() - 0.5);
    }

    function initPlayers(count) {
        players = [];
        for (let i = 0; i < count; i++) {
            players.push({
                id: i,
                name: i === 0 ? "æˆ‘(ç©å®¶0)" : `NPC ${i}`,
                hand: [deck.pop()],
                isOut: false,
                isProtected: false,
                isNPC: i !== 0
            });
        }
    }

    // äºŒã€çŒœæ‹³æ±ºå®šé †åº & ä¸‰ã€æ±ºå®šè¼ªæµæ–¹å‘
    function handleRPS() {
        const winnerIdx = Math.floor(Math.random() * players.length);
        currentPlayerIdx = winnerIdx;
        addLog(`ğŸ† çŒœæ‹³å‹åˆ©è€…æ˜¯ï¼š${players[winnerIdx].name}ï¼`, "important");

        if (players[winnerIdx].isNPC) {
            gameDir = Math.random() > 0.5 ? 1 : -1;
            addLog(`${players[winnerIdx].name} æ±ºå®šæ–¹å‘ï¼š${gameDir === 1 ? 'é †æ™‚é‡' : 'é€†æ™‚é‡'}`);
            beginTurn();
        } else {
            addLog("ä½ æ˜¯è´å®¶ï¼Œè«‹é¸æ“‡è¼ªæµæ–¹å‘ï¼š");
            addDirectionButtons();
        }
    }

    function addDirectionButtons() {
        const log = document.getElementById('log');
        const btnArea = document.createElement('div');
        btnArea.id = "dir-selector";
        btnArea.innerHTML = `
            <button onclick="setDirection(1)">ğŸ•’ é †æ™‚é‡</button>
            <button onclick="setDirection(-1)">ğŸ”„ é€†æ™‚é‡</button>
        `;
        log.prepend(btnArea);
    }

    function setDirection(dir) {
        gameDir = dir;
        document.getElementById('dir-selector').remove();
        addLog(`ä½ æ±ºå®šæ–¹å‘ç‚ºï¼š${gameDir === 1 ? 'é †æ™‚é‡' : 'é€†æ™‚é‡'}`);
        beginTurn();
    }

    // äº”ã€æŠ½ç‰Œ & å…­ã€å‡ºç‰Œ
    async function beginTurn() {
        if (isGameOver) return;
        updateUI();

        let p = players[currentPlayerIdx];
        p.isProtected = false; // ç§»é™¤ä¸Šä¸€å›åˆçš„ä¾å¥³ä¿è­·

        addLog(`--- è¼ªåˆ° ${p.name} çš„å›åˆ ---`);

        // æŠ½ç‰Œ (äº”)
        if (deck.length > 0) {
            const newCard = deck.pop();
            p.hand.push(newCard);
            
            // å…¬ä¸»è¦å‰‡ï¼šæŠ½åˆ°å…©å¼µå…¬ä¸»ç›´æ¥å‹åˆ© (å…«)
            if (p.hand.filter(c => c.v === 8).length === 2) {
                addLog(`ğŸŠ ${p.name} æ‰‹ä¸­åŒæ™‚æ“æœ‰å…©å¼µå…¬ä¸»ï¼é”æˆç‰¹æ®Šç²å‹ï¼`, "important");
                isGameOver = true;
                updateUI();
                return;
            }
        } else {
            checkFinalWinner();
            return;
        }

        updateUI();

        if (p.isNPC) {
            await sleep(1500);
            npcPlay(p);
        }
    }

    // ä¸ƒã€åŸ·è¡Œè§’è‰²åŠŸèƒ½
    function playCard(pIdx, cardIdx) {
        if (isGameOver || pIdx !== currentPlayerIdx) return;

        let p = players[pIdx];
        let card = p.hand[cardIdx];

        // ä¼¯çˆµå¤«äººæª¢æŸ¥ (ä¸ƒ)ï¼šæœ‰ 5,6 å¿…é ˆæ‰“å‡º 7
        const otherCard = p.hand[cardIdx === 0 ? 1 : 0];
        if (card.v !== 7 && p.hand.some(c => c.v === 7)) {
            if (otherCard && (otherCard.v === 5 || otherCard.v === 6)) {
                if (!p.isNPC) alert("ä¼¯çˆµå¤«äººè¦å‰‡ï¼šæ‰‹ä¸­æœ‰ç‹å­æˆ–åœ‹ç‹æ™‚ï¼Œå¿…é ˆå…ˆæ‰“å‡ºä¼¯çˆµå¤«äººï¼");
                return;
            }
        }

        // åŸ·è¡Œå‡ºç‰Œ
        card = p.hand.splice(cardIdx, 1)[0];
        addLog(`<b>${p.name}</b> æ‰“å‡ºäº† [${card.name}]`);

        // å…·é«”è§’è‰²é‚è¼¯ (ä¸€~å…«)
        switch (card.v) {
            case 1: executeGuard(p); break;
            case 2: executePriest(p); break;
            case 3: executeBaron(p); break;
            case 4: p.isProtected = true; addLog(`${p.name} é€²å…¥ä¾å¥³ä¿è­·ç‹€æ…‹ã€‚`); break;
            case 5: executePrince(p); break;
            case 6: executeKing(p); break;
            case 7: addLog("ä¼¯çˆµå¤«äººè¢«æ‰“å‡ºï¼Œæ²’æœ‰é¡å¤–æ•ˆæœã€‚"); break;
            case 8: p.isOut = true; addLog(`ğŸ˜± ${p.name} æ£„æ‰äº†å…¬ä¸»ï¼Œç›´æ¥å‡ºå±€ï¼`, "important"); break;
        }

        if (checkGameEnd()) return;
        
        // å…«ã€è¼ªåˆ°ä¸‹ä¸€å€‹äºº
        currentPlayerIdx = (currentPlayerIdx + gameDir + players.length) % players.length;
        while (players[currentPlayerIdx].isOut) {
            currentPlayerIdx = (currentPlayerIdx + gameDir + players.length) % players.length;
        }
        setTimeout(beginTurn, 1000);
    }

    // --- å„ç‰Œç¨®è©³ç´°åŠŸèƒ½ ---

    function executeGuard(p) {
        let targetIdx = findTarget(p.id);
        if (targetIdx === null) return addLog("æ²’æœ‰å¯é¸å–çš„ç›®æ¨™ã€‚");
        
        let guess;
        if (p.isNPC) {
            guess = Math.floor(Math.random() * 7) + 2; // NPC éš¨æ©ŸçŒœ 2-8
        } else {
            guess = prompt(`(è¡›å…µ) çŒœ ${players[targetIdx].name} çš„èº«åˆ† (ä¸èƒ½çŒœè¡›å…µï¼Œè¼¸å…¥2-8):`);
        }

        if (players[targetIdx].hand[0].v == guess) {
            addLog(`ğŸ¯ çŒœä¸­äº†ï¼${players[targetIdx].name} æ˜¯ [${guess}]ï¼Œå‡ºå±€ï¼`);
            players[targetIdx].isOut = true;
        } else {
            addLog(`ğŸ’¨ çŒœéŒ¯äº†ï¼Œ${players[targetIdx].name} é€ƒéä¸€åŠ«ã€‚`);
        }
    }

    function executePriest(p) {
        let targetIdx = findTarget(p.id);
        if (targetIdx === null) return;
        if (!p.isNPC) alert(`${players[targetIdx].name} çš„æ‰‹ç‰Œæ˜¯ï¼š[${players[targetIdx].hand[0].name}]`);
        addLog(`${p.name} æŸ¥çœ‹äº† ${players[targetIdx].name} çš„èº«åˆ†ã€‚`);
    }

    function executeBaron(p) {
        let targetIdx = findTarget(p.id);
        if (targetIdx === null) return;
        addLog(`âš”ï¸ ${p.name} èˆ‡ ${players[targetIdx].name} é€²è¡Œç§ä¸‹æ¯”å¤§å°...`);
        let v1 = p.hand[0].v;
        let v2 = players[targetIdx].hand[0].v;
        if (v1 > v2) {
            addLog(`ğŸ’€ ${players[targetIdx].name} é»æ•¸è¼ƒå°ï¼Œå‡ºå±€ï¼`);
            players[targetIdx].isOut = true;
        } else if (v1 < v2) {
            addLog(`ğŸ’€ ${p.name} é»æ•¸è¼ƒå°ï¼Œå‡ºå±€ï¼`);
            p.isOut = true;
        } else {
            addLog("âš–ï¸ å¹³æ‰‹ï¼Œç„¡äº‹ç™¼ç”Ÿã€‚");
        }
    }

    function executePrince(p) {
        let targetIdx;
        if (p.isNPC) targetIdx = p.id; // NPC å‚¾å‘é¸è‡ªå·±æ£„ç‰Œ
        else targetIdx = prompt(`(ç‹å­) è«‹è¼¸å…¥è¦èª°æ£„ç‰Œçš„ç©å®¶ç·¨è™Ÿ (0~${players.length-1}):`);
        
        let t = players[targetIdx];
        if (!t || t.isOut) return;
        
        addLog(`ğŸŒŠ ${t.name} æ£„æ‰äº†æ‰‹ç‰Œ [${t.hand[0].name}]`);
        if (t.hand[0].v === 8) {
            t.isOut = true;
            addLog(`ğŸ˜± æ£„æ‰çš„æ˜¯å…¬ä¸»ï¼${t.name} ç›´æ¥å‡ºå±€ï¼`);
        } else {
            t.hand = deck.length > 0 ? [deck.pop()] : [];
            addLog(`${t.name} æŠ½äº†ä¸€å¼µæ–°ç‰Œã€‚`);
        }
    }

    function executeKing(p) {
        let targetIdx = findTarget(p.id);
        if (targetIdx === null) return;
        let temp = p.hand[0];
        p.hand[0] = players[targetIdx].hand[0];
        players[targetIdx].hand[0] = temp;
        addLog(`ğŸ¤ ${p.name} èˆ‡ ${players[targetIdx].name} äº¤æ›äº†æ‰‹ç‰Œã€‚`);
    }

    // NPC AI è¡Œç‚º
    function npcPlay(p) {
        let cardIdx = 0;
        // ä¼¯çˆµå¤«äººå¼·è¿«è¦å‰‡
        if (p.hand.some(c => c.v === 7) && p.hand.some(c => c.v === 5 || c.v === 6)) {
            cardIdx = p.hand.findIndex(c => c.v === 7);
        } else {
            // é¿å…æ‰“å‡ºå…¬ä¸»
            cardIdx = p.hand[0].v === 8 ? 1 : 0;
        }
        playCard(p.id, cardIdx);
    }

    // --- è¼”åŠ©å·¥å…· ---

    function findTarget(meIdx) {
        // æ‰¾å°‹éè‡ªå·±ã€æœªå‡ºå±€ã€æœªå—ä¾å¥³ä¿è­·çš„äºº
        let valids = players.filter(p => !p.isOut && !p.isProtected && p.id !== meIdx);
        if (valids.length === 0) return null;
        return valids[0].id; // ç°¡å–® NPC é‚è¼¯ï¼šé¸ç¬¬ä¸€å€‹å¯é¸çš„äºº
    }

    function updateUI() {
        document.getElementById('deck-count').innerText = deck.length;
        document.getElementById('game-dir-display').innerText = `ğŸ”„ æ–¹å‘: ${gameDir === 1 ? 'é †æ™‚é‡' : 'é€†æ™‚é‡'}`;
        
        const list = document.getElementById('player-list');
        list.innerHTML = '';
        players.forEach((p, i) => {
            const div = document.createElement('div');
            div.className = `player-card ${p.isOut ? 'out' : ''} ${i === currentPlayerIdx ? 'active' : ''} ${p.isProtected ? 'protected' : ''}`;
            
            let actionHtml = "";
            if (!p.isOut && !p.isNPC && i === currentPlayerIdx) {
                p.hand.forEach((c, ci) => {
                    actionHtml += `<button onclick="playCard(${i}, ${ci})">${c.name} (${c.v})</button>`;
                });
            } else if (!p.isOut) {
                actionHtml = `<i>ğŸ´ æŒæœ‰ ${p.hand.length} å¼µç‰Œ</i>`;
            } else {
                actionHtml = "<b>- å·²æ·˜æ±° -</b>";
            }

            div.innerHTML = `<strong>${p.name}</strong><br>${actionHtml}`;
            list.appendChild(div);
        });
    }

    function addLog(msg, className = "") {
        const log = document.getElementById('log');
        const div = document.createElement('div');
        div.className = `log-entry ${className}`;
        div.innerHTML = `> ${msg}`;
        log.prepend(div);
    }

    function checkGameEnd() {
        const alive = players.filter(p => !p.isOut);
        if (alive.length === 1) {
            addLog(`ğŸ éŠæˆ²çµæŸï¼å”¯ä¸€çš„å€–å­˜è€…æ˜¯ï¼š${alive[0].name}`, "important");
            isGameOver = true;
            updateUI();
            return true;
        }
        return false;
    }

    function checkFinalWinner() {
        const alive = players.filter(p => !p.isOut);
        alive.sort((a,b) => b.hand[0].v - a.hand[0].v);
        addLog(`ğŸ ç‰Œåº«æŠ½ç©ºï¼é»æ•¸æ¯”æ‹¼ç²å‹è€…ï¼š${alive[0].name}`, "important");
        isGameOver = true;
        updateUI();
    }

    function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
</script>

</body>
</html>
